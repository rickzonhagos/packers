// Generated by Apple Swift version 3.0.1 (swiftlang-800.0.58.6 clang-800.0.42.1)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import UIKit;
@import CoreGraphics;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSCoder;

SWIFT_CLASS("_TtC16DrawerController18AnimatedMenuButton")
@interface AnimatedMenuButton : UIButton
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end

@class UIColor;

SWIFT_CLASS("_TtC16DrawerController19DrawerBarButtonItem")
@interface DrawerBarButtonItem : UIBarButtonItem
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithTarget:(id _Nullable)target action:(SEL _Nonnull)action;
- (nonnull instancetype)initWithTarget:(id _Nullable)target action:(SEL _Nonnull)action menuIconColor:(UIColor * _Nonnull)menuIconColor;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIGestureRecognizer;
@class UITouch;
@class NSBundle;
@protocol UIViewControllerTransitionCoordinator;

SWIFT_CLASS("_TtC16DrawerController16DrawerController")
@interface DrawerController : UIViewController <UIGestureRecognizerDelegate>
/**
  The center view controller.
  This can only be set via the init methods, as well as the \code
  setNewCenterViewController:...
  \endcode methods. The size of this view controller will automatically be set to the size of the drawer container view controller, and it’s position is modified from within this class. Do not modify the frame externally.
*/
@property (nonatomic, strong) UIViewController * _Nullable centerViewController;
/**
  The left drawer view controller.
  The size of this view controller is managed within this class, and is automatically set to the appropriate size based on the \code
  maximumLeftDrawerWidth
  \endcode. Do not modify the frame externally.
*/
@property (nonatomic, strong) UIViewController * _Nullable leftDrawerViewController;
/**
  The right drawer view controller.
  The size of this view controller is managed within this class, and is automatically set to the appropriate size based on the \code
  maximumRightDrawerWidth
  \endcode. Do not modify the frame externally.
*/
@property (nonatomic, strong) UIViewController * _Nullable rightDrawerViewController;
/**
  The maximum width of the \code
  leftDrawerViewController
  \endcode.
  By default, this is set to 280. If the \code
  leftDrawerViewController
  \endcode is nil, this property will return 0.0;
*/
@property (nonatomic) CGFloat maximumLeftDrawerWidth;
/**
  The maximum width of the \code
  rightDrawerViewController
  \endcode.
  By default, this is set to 280. If the \code
  rightDrawerViewController
  \endcode is nil, this property will return 0.0;
*/
@property (nonatomic) CGFloat maximumRightDrawerWidth;
/**
  The visible width of the \code
  leftDrawerViewController
  \endcode.
  Note this value can be greater than \code
  maximumLeftDrawerWidth
  \endcode during the full close animation when setting a new center view controller;
*/
@property (nonatomic, readonly) CGFloat visibleLeftDrawerWidth;
/**
  The visible width of the \code
  rightDrawerViewController
  \endcode.
  Note this value can be greater than \code
  maximumRightDrawerWidth
  \endcode during the full close animation when setting a new center view controller;
*/
@property (nonatomic, readonly) CGFloat visibleRightDrawerWidth;
/**
  A boolean that determines whether or not the panning gesture will “hard-stop” at the maximum width for a given drawer side.
  By default, this value is set to YES. Enabling \code
  shouldStretchDrawer
  \endcode will give the pan a gradual asymptotic stopping point much like \code
  UIScrollView
  \endcode behaves. Note that if this value is set to YES, the \code
  drawerVisualStateBlock
  \endcode can be passed a \code
  percentVisible
  \endcode greater than 1.0, so be sure to handle that case appropriately.
*/
@property (nonatomic) BOOL shouldStretchDrawer;
@property (nonatomic) CGFloat drawerDampingFactor;
@property (nonatomic) CGFloat shadowRadius;
@property (nonatomic) float shadowOpacity;
@property (nonatomic) CGFloat bezelRange;
/**
  The flag determining if a shadow should be drawn off of \code
  centerViewController
  \endcode when a drawer is open.
  By default, this is set to YES.
*/
@property (nonatomic) BOOL showsShadows;
@property (nonatomic) CGFloat animationVelocity;
/**
  Sets a callback to be called when a gesture has been completed.
  This block is called when a gesture action has been completed. You can query the \code
  openSide
  \endcode of the \code
  drawerController
  \endcode to determine what the new state of the drawer is.
  \param gestureCompletionBlock A block object to be called that allows the implementer be notified when a gesture action has been completed.

*/
@property (nonatomic, copy) void (^ _Nullable gestureCompletionBlock)(DrawerController * _Nonnull, UIGestureRecognizer * _Nonnull);
/**
  Sets a callback to be called to determine if a UIGestureRecognizer should recieve the given UITouch.
  This block provides a way to allow a gesture to be recognized with custom logic. For example, you may have a certain part of your view that should accept a pan gesture recognizer to open the drawer, but not another a part. If you return YES, the gesture is recognized and the appropriate action is taken. This provides similar support to how Facebook allows you to pan on the background view of the main table view, but not the content itself. You can inspect the \code
  openSide
  \endcode property of the \code
  drawerController
  \endcode to determine the current state of the drawer, and apply the appropriate logic within your block.
  Note that either \code
  openDrawerGestureModeMask
  \endcode must contain \code
  OpenDrawerGestureModeCustom
  \endcode, or \code
  closeDrawerGestureModeMask
  \endcode must contain \code
  CloseDrawerGestureModeCustom
  \endcode for this block to be consulted.
  \param gestureShouldRecognizeTouchBlock A block object to be called to determine if the given \code
  touch
  \endcode should be recognized by the given gesture.

*/
@property (nonatomic, copy) BOOL (^ _Nullable gestureShouldRecognizeTouchBlock)(DrawerController * _Nonnull, UIGestureRecognizer * _Nonnull, UITouch * _Nonnull);
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
/**
  Creates and initializes an \code
  DrawerController
  \endcode object with the specified center view controller, left drawer view controller, and right drawer view controller.
  \param centerViewController The center view controller. This argument must not be \code
  nil
  \endcode.

  \param leftDrawerViewController The left drawer view controller.

  \param rightDrawerViewController The right drawer controller.


  returns:
  The newly-initialized drawer container view controller.
*/
- (nonnull instancetype)initWithCenterViewController:(UIViewController * _Nonnull)centerViewController leftDrawerViewController:(UIViewController * _Nullable)leftDrawerViewController rightDrawerViewController:(UIViewController * _Nullable)rightDrawerViewController OBJC_DESIGNATED_INITIALIZER;
/**
  Creates and initializes an \code
  DrawerController
  \endcode object with the specified center view controller, left drawer view controller.
  \param centerViewController The center view controller. This argument must not be \code
  nil
  \endcode.

  \param leftDrawerViewController The left drawer view controller.


  returns:
  The newly-initialized drawer container view controller.
*/
- (nonnull instancetype)initWithCenterViewController:(UIViewController * _Nonnull)centerViewController leftDrawerViewController:(UIViewController * _Nullable)leftDrawerViewController;
/**
  Creates and initializes an \code
  DrawerController
  \endcode object with the specified center view controller, right drawer view controller.
  \param centerViewController The center view controller. This argument must not be \code
  nil
  \endcode.

  \param rightDrawerViewController The right drawer controller.


  returns:
  The newly-initialized drawer container view controller.
*/
- (nonnull instancetype)initWithCenterViewController:(UIViewController * _Nonnull)centerViewController rightDrawerViewController:(UIViewController * _Nullable)rightDrawerViewController;
- (void)encodeRestorableStateWithCoder:(NSCoder * _Nonnull)coder;
- (void)decodeRestorableStateWithCoder:(NSCoder * _Nonnull)coder;
@property (nonatomic, readonly, strong) UIViewController * _Nullable childViewControllerForStatusBarHidden;
@property (nonatomic, readonly, strong) UIViewController * _Nullable childViewControllerForStatusBarStyle;
/**
  Sets the maximum width of the left drawer view controller.
  If the drawer is open, and \code
  animated
  \endcode is YES, it will animate the drawer frame as well as adjust the center view controller. If the drawer is not open, this change will take place immediately.
  \param width The new width of left drawer view controller. This must be greater than zero.

  \param animated Determines whether the drawer should be adjusted with an animation.

  \param completion The block called when the animation is finished.

*/
- (void)setMaximumLeftDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/**
  Sets the maximum width of the right drawer view controller.
  If the drawer is open, and \code
  animated
  \endcode is YES, it will animate the drawer frame as well as adjust the center view controller. If the drawer is not open, this change will take place immediately.
  \param width The new width of right drawer view controller. This must be greater than zero.

  \param animated Determines whether the drawer should be adjusted with an animation.

  \param completion The block called when the animation is finished.

*/
- (void)setMaximumRightDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/**
  Sets the new \code
  centerViewController
  \endcode.
  This sets the view controller and will automatically adjust the frame based on the current state of the drawer controller. If \code
  closeAnimated
  \endcode is YES, it will immediately change the center view controller, and close the drawer from its current position.
  \param centerViewController The new \code
  centerViewController
  \endcode.

  \param closeAnimated Determines whether the drawer should be closed with an animation.

  \param completion The block called when the animation is finsihed.

*/
- (void)setCenter:(UIViewController * _Nonnull)newCenterViewController withCloseAnimation:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/**
  Sets the new \code
  centerViewController
  \endcode.
  This sets the view controller and will automatically adjust the frame based on the current state of the drawer controller. If \code
  closeFullAnimated
  \endcode is YES, the current center view controller will animate off the screen, the new center view controller will then be set, followed by the drawer closing across the full width of the screen.
  \param newCenterViewController The new \code
  centerViewController
  \endcode.

  \param fullCloseAnimated Determines whether the drawer should be closed with an animation.

  \param completion The block called when the animation is finsihed.

*/
- (void)setCenter:(UIViewController * _Nonnull)newCenterViewController withFullCloseAnimation:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (void)toggleLeftDrawerSideWithAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (void)toggleRightDrawerSideWithAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/**
  Closes the open drawer.
  \param animated Determines whether the drawer side should be closed animated

  \param completion The block that is called when the close is complete

*/
- (void)closeDrawerWithAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidDisappear:(BOOL)animated;
@property (nonatomic, readonly) BOOL shouldAutomaticallyForwardAppearanceMethods;
@property (nonatomic, readonly) BOOL shouldAutorotate;
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldReceiveTouch:(UITouch * _Nonnull)touch;
@end

@class UIStoryboardSegue;

@interface DrawerController (SWIFT_EXTENSION(DrawerController))
- (void)awakeFromNib;
- (void)prepareForSegue:(UIStoryboardSegue * _Nonnull)segue sender:(id _Nullable)sender;
@end


SWIFT_CLASS("_TtC16DrawerController11DrawerSegue")
@interface DrawerSegue : UIStoryboardSegue
- (void)perform;
- (nonnull instancetype)initWithIdentifier:(NSString * _Nullable)identifier source:(UIViewController * _Nonnull)source destination:(UIViewController * _Nonnull)destination OBJC_DESIGNATED_INITIALIZER;
@end


@interface UIViewController (SWIFT_EXTENSION(DrawerController))
@end


@interface UIViewController (SWIFT_EXTENSION(DrawerController))
@property (nonatomic, readonly, strong) DrawerController * _Nullable evo_drawerController;
@property (nonatomic, readonly) CGRect evo_visibleDrawerFrame;
@end

#pragma clang diagnostic pop
